# Copyright (c) 2014 FireEye, Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.

import sys
import string
import re
import os
import argparse

def getUnicodeString(buf,pos):
	out = ""
	for i in range(len(buf[pos:])):
		if ord(buf[pos+i]) == 0 and ord(buf[pos+i+1]) == 0:
			out += "\x00"
			break
		out += buf[pos+i]
	
	if out == "":
		return None
	else:
		return out
		
def getMutex(buf, exitpos, persistpos):
	#do a backwards comparison from PERSIST and EXIT and continue until there is a mismatch or two null bytes, calculate beginning of the mutex this way
	cnt = 1
	while 1:
		exitc = buf[exitpos - cnt]
		exitc2 = buf[exitpos - cnt - 1]
		persistc = buf[persistpos - cnt]
		persistc2 = buf[persistpos - cnt - 1]
		if exitc != persistc:
			if buf[persistpos - cnt + 1] == "\x00":
				out = buf[persistpos - cnt + 2:persistpos]
			else:
				out = buf[persistpos - cnt + 1:persistpos]
			return out
		if (exitc == "\x00" and exitc2 == "\x00") or (persistc == "\x00" and persistc2 == "\x00"):
			out = buf[persistpos - cnt + 1:persistpos]
			return out
		cnt+=1
	
	

def unicodifyre(s):
	return "\\x00".join(s) + "\\x00"
	
def unicodify(s):
	return "\x00".join(s) + "\x00"

def getConfig(f,buf):
	persistre = unicodifyre("PERSIST")
	persist = unicodify("PERSIST")
	exit = unicodify("EXIT")
	persistpattern = r"(([^\x00]\x00){4,})" + persistre
	match = re.search(persistpattern, buf)
	if match is not None:
		print "xtrat config located in %s" % f
		persistpos = string.find(buf,match.group(0))
		persistoffs = string.find(buf[persistpos:],persist)
		persistpos += persistoffs
		exitpos = string.rfind(buf[:persistpos],exit)
		#match last 3 characters of mutex as a sanity check
		if exitpos != -1 and buf[exitpos-6:exitpos] == match.group(1)[-6:]:
			configpos = None
			if persistpos - exitpos == 0x60:
				print "possible version 1.3.6.x config block found.."
				mutex = getMutex(buf, exitpos, persistpos)
				print "mutex: %s" % mutex
				configpos = persistpos - len(mutex) - 0x3c8
				configlen = 0xe10
				
			elif persistpos - exitpos == 0x38:
				print "possible version 3.x config block found.."
				mutex = getMutex(buf, exitpos, persistpos)
				print "mutex: %s" % mutex
				configpos = persistpos - len(mutex) - 0x33e
				configlen = 0x7f0
				
			elif persistpos - exitpos == 0x7a:
				print "possible version 2.x config block found.."
				mutex = getMutex(buf, exitpos, persistpos)
				print "mutex: %s" % mutex
				configpos = persistpos - len(mutex) - 0x109e
				configlen = 0x1390
			
			if configpos is not None:
				print "config located at %08X" % configpos
				wp = open(f + ".cfg", "wb")
				wp.write(buf[configpos:configpos+configlen])
				wp.close()
		
	else:
		print "could not locate xtrat config"

def getFile(f):
	rp = open(f, "rb")
	buf = rp.read()
	rp.close()
	return buf

if __name__ == "__main__":
	parser=argparse.ArgumentParser(description="scans for Xtreme RAT config in memory dumps and writes them to a file of the same name with '.cfg' appended")
	parser.add_argument('i', metavar='Input', help='a path to a memory dump or directory of memory dumps')

	args = parser.parse_args()

	if os.path.isfile(args.i):
		f = sys.argv[1]
		buf = getFile(f)
		getConfig(f,buf)
	elif os.path.isdir(args.i):
		d = args.i
		for f in os.listdir(d):
			path = os.path.join(d, f)
			if os.path.isfile(path):
				buf = getFile(path)
				getConfig(path,buf)



